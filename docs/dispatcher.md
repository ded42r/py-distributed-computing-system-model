# диспетчер требования
* Обрабатывает UDP-пакеты от клиентов и вычислителей.
* Слушает на порту, задаваемом в конфиге диспетчера.  
* Получая запрос от клиента - выбирает доступного вычислителя, посылает ему задание. 
* Получая ответ от вычислителя - возвращает ответ клиенту, инициировавшему конкретный запрос
* Требуется обеспечить динамическую регистрацию вычислителей диспетчером
* отслеживание неработоспособности отдельных вычислителей, 
* обеспечить гарантированное выполнение запросов 
    * если выбранный для обработки конкретного клиентского запроса вычислитель за заданный промежуток не ответил - диспетчер посылает запрос другому свободному вычислителю, либо держит запрос в очереди, пока не истечет заданный таймаут).

# конфиг
* _client_address_ - хост и порт, где слушать команды от клиентов и калькуляторов
`    "client_address": {
        "host": "0.0.0.0",
        "port": 5555
    }`
* _timeout_task_placement_ - таймаут размещения задачи от клиента в секундах. Если за это время не удалось 
найти свободный вычислитель, то больше эта задача не будет отправляться для исполнения.


# Протокол обмена клиента и диспетчера
## add_task - добавление задания
Клиент отправляет запрос  диспетчеру, ждет подтверждения.
пример данных: `{'method': 'add_task', 'params': {'task_id': 5}, 'packet_type': 1, 'transmission_id': 1598326709621}`

Логика обработки:
0. от клиента диспетчеру команда пришла
0. диспетчер отвечает клиенту что принял команду в обработку
0. диспетчер проверяет что команда на добавление не была дублем от клиента в реестре задач
0. Если не дубль, то:
    0. диспетчер вносит в реестр задач новую таску (client_addr, task_id)
    0. переход в perform_task    
 
## notify_task - уведомление по заданию
Диспетчер отправляет запрос клиенту. Подтверждения не ждет кроме случая уведомления об успешном выполнении.
пример данных: `{'method': 'notify_task', 'params': {'status': 'success', 'task_id': 5}, 'packet_type': 0}`

Статусы могут быть:
* success - успешно выполнено
* error - не удалось выполнить
* failed_post - не удалось разместить

Если статус = success, то требуется подтверждение от клиента 

# Протокол обмена диспетчера и вычислителя
## perform_task - выполнение задания
Диспетчер отправляет вычислителю. Ждет подтверждения.
пример данных: `{'method': 'perform_task', 'params': {'task_id': 5}, 'packet_type': 1, 'transmission_id': 1598326709000}`

0. диспетчер в списке вычислителей ищет первый свободный калькулятор(K1) пока не истек таймаут размещения задания
    0. диспетчер отправляет K1 команду на выполнение задания
    0. диспетчер помечает К1 как занятый
    0. диспетчер ждет подтверждения от К1 в течении таймаута
    0. если подтверждения нет:
        * то К1 помечается как недоступный
        * ищем другого вычислителя 
0. Если не удалось разместить задачу, то диспетчер отправляет клиенту команду notify_task, status=failed_post
 
## completed_task - вычислитель выполнил задачу
Вычислитель отправляет диспетчеру. Ждет подтверждения.
пример данных: `{'method': 'completed_task', 'params': {'task_id': 5}, 'packet_type': 1, 'transmission_id': 1598326709000}`

0. Обновляем задачу в реестре задач 
    * удаляется вычислитель
    * меняется статус на _"отправка клиенту"_ 
    * обновляется время
0. Меняет статус вычислителя:
    * status меняет на _ready_
    * установить время обновления статуса на текущее
0. отправляется подтверждение вычислителю
0. Отправить клиенту команду notify_task
    * если получено подтверждение, то меняем статус в реестре задач на _"результат отправлен"_


## heartbeat - уведомление о доступности вычислителя
Калькулятор отправляет запрос диспетчеру. Подтверждения не ждет
пример данных: `{'method': 'heartbeat', 'params': {'status': 'ready'}, 'packet_type': 0}`

Возможные статусы:
* _ready_ - готов к выполнению задач
* _busy_ - занят выполнением задач

0. Диспетчер добавляет/обновляет в реестр вычислителей запись
Реестр это хэш таблица (addr, port): {информация}
    * время обновления(когда поступила последняя информация)
    * статус вычислителя


